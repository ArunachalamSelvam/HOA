/*
*  Copyright (c) 2019. All right reserved
* Created on 2024-04-22 ( Date ISO 2024-04-22 - Time 21:42:02 )
* Generated by Telosys Tools Generator ( version 3.3.0 )
*/
package com.hoa.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.hoa.repositories.ContractRepository;
import com.hoa.requestEntities.ClientRequest;
import com.hoa.requestEntities.Contractrequest3;
import com.hoa.responseEntities.ContractListResponse;
import com.hoa.responseEntities.ContractUpdateResponse;
import com.hoa.controller.ContractController;
import com.hoa.dto.AddressDTO;
import com.hoa.dto.ClientDTO;
import com.hoa.dto.CommunityDTO;
import com.hoa.dto.ContractDTO;
import com.hoa.entities.Address;
import com.hoa.entities.Client;
import com.hoa.entities.ClientAddress;
import com.hoa.entities.Community;
import com.hoa.entities.Contract;
import com.hoa.entities.User;
import com.hoa.enums.ContractActiveStatus;
import com.hoa.exception.AddressNotFoundException;
import com.hoa.exception.ClientIdNotFoundException;
import com.hoa.exception.CommunityNotFoundException;
import com.hoa.exception.ContractNotFoundException;
import com.hoa.exception.UserNotFoundException;
import com.hoa.service.ContractService;
import com.hoa.utils.EntityDTOMapper;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;

import javax.mail.MessagingException;

/**
 * Service Implementation for managing {@link Contract}.
 * 
 * @author aek
 */
@Service
@Transactional
public class ContractServiceImpl implements ContractService {

	private static final String CHARACTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
	private static final int CODE_LENGTH = 16;
	private static final Random RANDOM = new SecureRandom();

	private final ContractRepository repository;
	private final UserService userService;
	private final ClientService clientService;
	private final AddressService addressService;
	private final ClientaddressService clientAddressService;
	private final CommunityService communityService;
	private final EmailService emailService;
	private final EntityDTOMapper entityDtoMapper;
    private final Logger logger = LoggerFactory.getLogger(ContractServiceImpl.class);


	@Autowired
	public ContractServiceImpl(ContractRepository repository, UserService userService, ClientService clientService,
			AddressService addressService, ClientaddressService clientAddressService, CommunityService communityService,
			EntityDTOMapper entityDtoMapper,EmailService emailService) {
		this.userService = userService;
		this.repository = repository;
		this.clientService = clientService;
		this.addressService = addressService;
		this.clientAddressService = clientAddressService;
		this.communityService = communityService;
		this.entityDtoMapper = entityDtoMapper;
		this.emailService = emailService;
	}



	/**
	 * {@inheritDoc}
	 */
	@Override
	public Contract create(Contract d) {
		try {
			return repository.save(d);

		} catch (Exception ex) {
			return null;
		}
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @throws ContractNotFoundException
	 */
	@Override
	public Contract update(Integer id, Contract contract) throws ContractNotFoundException {
		// Retrieve the contract with the given ID from the database
		Contract existingContract = repository.findById(id)
				.orElseThrow(() -> new ContractNotFoundException("Contract not found with id: " + id));

		// Update the existing contract with the values from the provided contract
//        existingContract.setSomeField(contract.getSomeField()); // Update fields as needed

		// Save the updated contract
		contract.setContractid(id);
		return repository.save(contract);
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @throws ContractNotFoundException
	 */
	@Override
	public Contract getOne(Integer id) throws ContractNotFoundException {
		try {
			return repository.findById(id).orElse(null);

		} catch (Exception ex) {
			throw new ContractNotFoundException("Contract with Id " + id + " not found.");
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public List<Contract> getAll() {
		try {
			return repository.findAll();

		} catch (Exception ex) {
			return Collections.emptyList();
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getTotal() {
		try {
			return repository.count();
		} catch (Exception ex) {
			return 0;
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void delete(Integer id) {
		repository.deleteById(id);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Page<Contract> findAllPaginate(Pageable pageable) {

		return repository.findAll(pageable);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Page<Contract> findAllSpecification(Specification<Contract> specs, Pageable pageable) {
		return repository.findAll(specs, pageable);
	}

	@Override
	public Integer getContractIdByContractCode(String contractCode) {
		return repository.findContractIdByContractCode(contractCode);
	}

	@Override
	public boolean existsByContractCode(String contractCode) {
		return repository.countByContractCode(contractCode) > 0;
	}

	@Override
	@Transactional(rollbackFor = Exception.class)
	public Contract createContract(Contractrequest3 contractRequest) throws ClientIdNotFoundException {
		ContractDTO contractDto = contractRequest.getContractDto();

		// Generating ContractCode
		String contractCode = generateUniqueContractCode();
		// Set the ContractCode to the Contract
		contractDto.setContractcode(contractCode);

		ClientRequest clientRequest = contractRequest.getClientRequest();
		User user = entityDtoMapper.toEntity(clientRequest.getUserDto());
		User savedUser = userService.create(user);

		ClientDTO clientDto = clientRequest.getClientDto();
		clientDto.setUserid(savedUser.getUserId());
		Client client = entityDtoMapper.toEntity(clientDto);
		Client savedClient = clientService.create(client);

		AddressDTO addressDTO = clientRequest.getAddressDto();
		Address address = entityDtoMapper.toEntity(addressDTO);
		Address savedAddress = addressService.create(address);

		ClientAddress clientAddress = new ClientAddress();
		clientAddress.setAddressid(savedAddress.getAddressId());
		clientAddress.setClientid(savedClient.getClientid());
		clientAddressService.create(clientAddress);

		contractDto.setClientid(savedClient.getClientid());

		AddressDTO communityAddressDto = contractRequest.getAddressDto();
		Address communityAddress = entityDtoMapper.toEntity(communityAddressDto);
		Address savedCommunityAddress = addressService.create(communityAddress);
		contractDto.setBusinessaddressid(savedCommunityAddress.getAddressId());

		String communityCode = communityService.generateUniqueCommunityCode();
		CommunityDTO communityDto = new CommunityDTO();
		communityDto.setName(contractDto.getBuisnessname());
		communityDto.setCommunityCode(communityCode);
		communityDto.setAddressId(savedCommunityAddress.getAddressId());
		communityDto.setCommunitySize(contractDto.getSizeofthecommunity());
		communityDto.setPlanId(contractDto.getPlanid());
		communityDto.setCreatedById(contractDto.getCreatedbyid());
		communityDto.setCreatedDate(contractDto.getCreateddate());
		communityDto.setContactPerson(
				savedUser.getFirstName() + " " + savedUser.getMiddleName() + " " + savedUser.getLastName());

		Community community = entityDtoMapper.toEntity(communityDto);
		Contract contract = entityDtoMapper.toEntity(contractDto);
		Contract savedContract = repository.save(contract);

		community.setContractId(savedContract.getContractid());
		Community savedCommunity = communityService.create(community);

		clientService.updateClientCommunityId(savedClient.getClientid(), savedCommunity.getCommunityId());

		return savedContract;
	}

	@Override
	@Transactional(rollbackFor = Exception.class)
	public Contract updateContract(Integer contractId,Contractrequest3 contractRequest) throws ClientIdNotFoundException, CommunityNotFoundException, UserNotFoundException, AddressNotFoundException {
	    ContractDTO contractDto = contractRequest.getContractDto();

	    // Retrieve the existing contract using the contract ID
	    Contract existingContract = repository.findById(contractId)
	            .orElseThrow(() -> new ClientIdNotFoundException("Contract not found"));

	    // Update the contract details
	    existingContract.setBuisnessname(contractDto.getBuisnessname());
	    existingContract.setPlanid(contractDto.getPlanid());
	    existingContract.setCreatedbyid(contractDto.getCreatedbyid());
	    existingContract.setCreateddate(contractDto.getCreateddate());
	    existingContract.setSizeofthecommunity(contractDto.getSizeofthecommunity());

	    // Update the related client and user details
	    ClientRequest clientRequest = contractRequest.getClientRequest();
	    User user = entityDtoMapper.toEntity(clientRequest.getUserDto());
	    User updatedUser = userService.update(user.getUserId(),user);

	    ClientDTO clientDto = clientRequest.getClientDto();
	    clientDto.setUserid(updatedUser.getUserId());
	    clientDto.setDisplayname(user.getFirstName());
	    Client client = entityDtoMapper.toEntity(clientDto);
	    Client updatedClient = clientService.update(client.getClientid(),client);

	    AddressDTO addressDTO = clientRequest.getAddressDto();
	    Address address = entityDtoMapper.toEntity(addressDTO);
	    Address updatedAddress = addressService.update(address.getAddressId(),address);

	    ClientAddress clientAddress = clientAddressService.getClientAddressByClientId(updatedClient.getClientid());
//	    clientAddress.setAddressid(updatedAddress.getAddressId());
//	    clientAddressService.update(clientAddress);

//	    existingContract.setClientid(updatedClient.getClientid());

	    Integer communityId = client.getCommunityid();
	    AddressDTO communityAddressDto = contractRequest.getAddressDto();
	    Address communityAddress = entityDtoMapper.toEntity(communityAddressDto);
	    Address updatedCommunityAddress = addressService.update(communityAddress.getAddressId(),communityAddress);
	    existingContract.setBusinessaddressid(updatedCommunityAddress.getAddressId());

//	    CommunityDTO communityDto = communityService.findByContractId(existingContract.getContractid());
	
	    Community community = communityService.getOne(communityId);
	    community.setCommunityId(communityId);
	    community.setName(existingContract.getBuisnessname());
	    community.setCommunitySize(existingContract.getSizeofthecommunity());
	    community.setPlanId(existingContract.getPlanid());
	    community.setCreatedById(existingContract.getCreatedbyid());
	    community.setCreatedDate(existingContract.getCreateddate());
	    community.setContactPerson(
	            updatedUser.getFirstName() + " " + updatedUser.getMiddleName() + " " + updatedUser.getLastName());
//	    communityDto.setAddressId(updatedCommunityAddress.getAddressId());

//	    Community community = entityDtoMapper.toEntity(communityDto);
	    Community updatedCommunity = communityService.update(communityId,community);

//	    clientService.updateClientCommunityId(updatedClient.getClientid(), updatedCommunity.getCommunityId());

	    // Save the updated contract
	    Contract updatedContract = repository.save(existingContract);

	    return updatedContract;
	}

	
	@Override
	@Transactional
	public boolean updateActiveStatus(Integer clientId, Boolean activeStatus)
			throws CommunityNotFoundException, ContractNotFoundException, UserNotFoundException, MessagingException {

		Client client = clientService.getOne(clientId);
		userService.setActiveStatus(client.getUserid(), true);
		Integer communityId = client.getCommunityid();

		Community community = communityService.getOne(communityId);

		Integer contractId = community.getContractId();
		if (community != null) {
			boolean isCommunityUpdated = communityService.updateActiveStatus(communityId, activeStatus);
			Contract updatedContract = null;
			if (activeStatus == true) {
				Contract contract = repository.findById(contractId).get();

				System.out.println("\033[31m" + "Contract Before Update : " + contract + "\033[0m");

				String contractActiveStatus = ContractActiveStatus.APPROVED.toString();

				contract.setActiveStatus(contractActiveStatus);
				updatedContract = repository.save(contract);
				
				User user = userService.getOne(client.getUserid());
				user.setActiveStatus(true);
				emailService.sendUserCredentials(user.getEmailId(), user.getFirstName()+" "+user.getMiddleName()+" "+user.getLastName(), user.getPassword());
				System.out.println("\033[31m" + "FirstClient active status changed and Email send with credentials."+ "\033[0m");

				System.out.println("\033[31m" + "Contract After Update : " + updatedContract + "\033[0m");
			} else {
				Contract contract = repository.findById(contractId).get();

				System.out.println("\033[31m" + "Contract Before Update : " + contract + "\033[0m");

				String contacrActiveStatus = ContractActiveStatus.APPROVAL_PENDING.toString();

				contract.setActiveStatus(contacrActiveStatus);
				updatedContract = repository.save(contract);

				System.out.println("\033[31m" + "Contract After Update : " + updatedContract + "\033[0m");
			}
			return isCommunityUpdated && updatedContract != null;
		} else {
			throw new CommunityNotFoundException("Community with the Id : " + communityId + " not found.");
		}
	}

	@Override
	public List<ContractListResponse> findEmployeeContractsBySalesPersonId(Integer salesManagerId,
			Integer salesPersonId) {
		List<Map<String, Object>> results = null;

		if (salesManagerId == 0 && salesPersonId == 0) {
			results = repository.findContractsBySalesManagerIdAndSalesPersonId();

		} else if (salesManagerId > 0 && salesPersonId == 0) {
			results = repository.findContractsBySalesManagerIdAndSalesPersonId(salesManagerId);
		} else if (salesManagerId > 0 && salesPersonId > 0) {
			results = repository.findContractsBySalesManagerIdAndSalesPersonId(salesPersonId, salesManagerId);
		}
		List<ContractListResponse> contractResponses = new ArrayList<>();
		for (Map<String, Object> row : results) {
			contractResponses.add(mapToEmployeeContractResponse(row));
		}
		return contractResponses;
	}
	
	
	@Override
    public ContractUpdateResponse getContractUpdateResponse(Integer contractId) {
        try {
            List<Map<String, Object>> response = repository.getContractUpdateResponse(contractId);
            logger.info("Response from repository: {}", response);
            return mapToContractUpdateResponse(response);
        } catch (Exception ex) {
            logger.error("Error retrieving data: ", ex);
            return null;
        }
    }

	private ContractListResponse mapToEmployeeContractResponse(Map<String, Object> row) {
		ContractListResponse contractResponse = new ContractListResponse();
		contractResponse.setContractId((Integer) row.get("contractId"));
		contractResponse.setClientId((Integer) row.get("clientId"));
		contractResponse.setContractCode((String) row.get("contractCode"));
		contractResponse.setContractActiveStatus((String) row.get("contractActiveStatus"));
		contractResponse.setBusinessName((String) row.get("businessName"));
		contractResponse.setAnnualRenewalFee((Double) row.get("annualRenewalFee"));
		contractResponse.setRenewalCycles((String) row.get("renewalCycles"));
		contractResponse.setIsTermsAccepted((Boolean) row.get("isTermsAccepted"));
		contractResponse.setCommunityId((Integer) row.get("communityId"));
		contractResponse.setCreatedDate((Date) row.get("createdDate"));
		contractResponse.setClientDisplayName((String) row.get("clientDisplayName"));
		contractResponse.setClientActiveStatus((Boolean) row.get("clientActiveStatus"));
		contractResponse.setUserFirstName((String) row.get("userFirstName"));
		contractResponse.setUserLastName((String) row.get("userLastName"));
		contractResponse.setEmailId((String) row.get("emailId"));
		contractResponse.setMobileNumber((String) row.get("mobileNumber"));
		contractResponse.setCity((String) row.get("city"));
		contractResponse.setZipCode((Integer) row.get("zipCode"));
		contractResponse.setCountry((String) row.get("country"));
		contractResponse.setSalesPersonEmail((String) row.get("salesPersonEmailId"));
		contractResponse.setSalesPersonMobileNumber((String) row.get("salesPersonMobileNumber"));
		return contractResponse;
	}
	
	
	private ContractUpdateResponse mapToContractUpdateResponse(List<Map<String, Object>> response) {
        ContractUpdateResponse  contractUpdateResponse = new ContractUpdateResponse();
        for (Map<String, Object> record : response) {
          
            // Set fields
            contractUpdateResponse.setContractId((Integer) record.get("contractId"));
            contractUpdateResponse.setSalesPersonId((Integer) record.get("salesPersonId"));
            contractUpdateResponse.setClientId((Integer) record.get("clientId"));
            contractUpdateResponse.setContractCode((String) record.get("contractCode"));
            contractUpdateResponse.setBusinessName((String) record.get("businessName"));
            contractUpdateResponse.setBusinessAddressId((Integer) record.get("businessAddressId"));
            contractUpdateResponse.setCommunicationChannel((String) record.get("communicationChannel"));
            contractUpdateResponse.setPlanId((Integer) record.get("planId"));
            contractUpdateResponse.setAnnualRenewalFee((Double) record.get("annualRenewalFee"));
            contractUpdateResponse.setOneTimeSetUp((Double) record.get("oneTimeSetUp"));
            contractUpdateResponse.setSizeOfTheCommunity((Integer) record.get("sizeOfTheCommunity"));
            contractUpdateResponse.setRenewalCycles((String) record.get("renewalCycles"));
            contractUpdateResponse.setIsTermsAccepted((Boolean) record.get("isTermsAccepted"));
            contractUpdateResponse.setCreatedById((Integer) record.get("createdById"));
            contractUpdateResponse.setCreatedDate((Date) record.get("createdDate"));
            contractUpdateResponse.setModifiedById((Integer) record.get("modifiedById"));
            contractUpdateResponse.setModifiedDate((Date) record.get("modifiedDate"));
            contractUpdateResponse.setSalesPersonName((String) record.get("salesPersonName"));

            // Business Address
            contractUpdateResponse.setBusinessAddress((String) record.get("businessAddress"));
            contractUpdateResponse.setBusinessAddressCity((String) record.get("businessAddressCity"));
            contractUpdateResponse.setBusinessAddressStateId((Integer) record.get("businessAddressStateId"));
            contractUpdateResponse.setBusinessAddressCountryId((Integer) record.get("businessAddressCountryId"));
            contractUpdateResponse.setBusinessAddressZipCode((Integer) record.get("businessAddressZipCode"));
            contractUpdateResponse.setBusinessAddressActiveStatus((Boolean) record.get("businessAddressActiveStatus"));

            // Client User
            contractUpdateResponse.setUserId((Integer) record.get("userId"));
            contractUpdateResponse.setFirstName((String) record.get("firstName"));
            contractUpdateResponse.setMiddleName((String) record.get("middleName"));
            contractUpdateResponse.setLastName((String) record.get("lastName"));
            contractUpdateResponse.setMobileNumber((String) record.get("mobileNumber"));
            contractUpdateResponse.setMobileIsVerified((Boolean) record.get("mobileIsVerified"));
            contractUpdateResponse.setEmailId((String) record.get("emailId"));
            contractUpdateResponse.setEmailIdIsVerified((Boolean) record.get("emailIdIsVerified"));
            contractUpdateResponse.setIsClient((Boolean) record.get("isClient"));
            contractUpdateResponse.setOtp((Integer) record.get("otp"));
            contractUpdateResponse.setRoleId((Integer) record.get("roleId"));
            contractUpdateResponse.setPassword((String) record.get("password"));
            contractUpdateResponse.setUserActiveStatus((Boolean) record.get("userActiveStatus"));
            contractUpdateResponse.setLastLogin((Date) record.get("lastLogin"));

            // Client
            contractUpdateResponse.setCommunityId((Integer) record.get("communityId"));
            contractUpdateResponse.setDisplayName((String) record.get("displayName"));
            contractUpdateResponse.setNumberOfHouses((Integer) record.get("numberOfHouses"));
            contractUpdateResponse.setClientActiveStatus((Boolean) record.get("clientActiveStatus"));

            // Client Address Aggregation
            contractUpdateResponse.setClientAddressId((Integer) record.get("clientAddressId"));
            contractUpdateResponse.setClientAddress((String) record.get("clientAddress"));
            contractUpdateResponse.setClientAddressCity((String) record.get("clientAddressCity"));
            contractUpdateResponse.setClientAddressStateId((Integer) record.get("clientAddressStateId"));
            contractUpdateResponse.setClientAddressCountryId((Integer) record.get("clientAddressCountryId"));
            contractUpdateResponse.setClientAddressZipCode((Integer) record.get("clientAddressZipCode"));
            contractUpdateResponse.setClientAddressActiveStatus((Boolean) record.get("clientAddressActiveStatus"));

            // Plan
            contractUpdateResponse.setPlanRangeId((Integer) record.get("planRangeId"));
            contractUpdateResponse.setPlanPeriodId((Integer) record.get("planPeriodId"));
            contractUpdateResponse.setPlanTypeId((Integer) record.get("planTypeId"));
            contractUpdateResponse.setPlanPrice((Double) record.get("planPrice"));
//            contractUpdateResponses.add(contractUpdateResponse);
        }
        return contractUpdateResponse;
    }
	
	// Method to generate a random ContractCode with custom length and characters
	@Override
	public String generateUniqueContractCode() {
		String contractCode;
		do {
			contractCode = generateCustomRandomContractCode();
		} while (repository.countByContractCode(contractCode) == 1); // Check uniqueness
		return contractCode;
	}

	// Helper method to generate a custom random ContractCode
	private String generateCustomRandomContractCode() {
		StringBuilder contractCode = new StringBuilder(CODE_LENGTH);
		for (int i = 0; i < CODE_LENGTH; i++) {
			contractCode.append(CHARACTERS.charAt(RANDOM.nextInt(CHARACTERS.length())));
		}
		return contractCode.toString();
	}






}
